#include <bits/stdc++.h>
using namespace std;

class AVLNode {
public:
    string word;
    string definition;
    int balanceFactor;
    AVLNode *left, *right;

    AVLNode(string w, string d, int b): word(w), definition(d), balanceFactor(b), left(nullptr), right(nullptr) {}
};

class AVLTree {
    AVLNode* root;

    int __height(AVLNode* node) {
        if (!node) {
            return 0;
        }

        int leftHeight = __height(node->left);
        int rightHeight = __height(node->right);

        return max(leftHeight, rightHeight) + 1;
    }

    int calculateBalance(AVLNode* node) {
        if (!node) return 0;
        return __height(node->left) - __height(node->right);
    }

    void balanceTree(AVLNode* node, string w) {
        if ( -1 <= node->balanceFactor && node->balanceFactor <= 1 ) return;

        if (w < node->left->left->word) {
            LL(node);
        } else if (w < node->right->right->word) {
            RR(node);
        } else if (w < node->left->right->word) {
            RL(node);
        } else if (w < node->right->left->word) {
            LR(node);
        }
    }


    void RR(AVLNode* node) {
        AVLNode* temp;
        temp = node;
        node = node->right;
        node->left = temp;
    }
    void LL(AVLNode* node) {
        AVLNode* temp;
        temp = node;
    }
    void LR(AVLNode* node) {}
    void RL(AVLNode* node) {}

public:
    AVLTree(): root(nullptr) {}

    void insert(string w, string d) {
        if (root == nullptr) {
            root = new AVLNode(w, d, 0);
            return;
        }

        AVLNode *curr, *prev, *prev2;
        curr = root;
        prev = curr;
        while (curr) {
            prev2 = prev;
            prev = curr;

            if (w == curr->word) {
                // same node
                curr->definition = d;
                return;
            } else if (w < curr->word) {
                curr = curr->left;
            } else if (w > curr->word) {
                curr = curr->right;
            }
        }

        if (w < prev->word) {
            prev->left = new AVLNode(w, d, 0);
        } else if (w > prev->word) {
            prev->right = new AVLNode(w, d, 0);
        }

        prev->balanceFactor = calculateBalance(prev);
        prev2->balanceFactor = calculateBalance(prev2);

        balanceTree(prev2, w);
    }
    void search() {}
    void remove() {}

    int height() {
        return __height(this->root);
    }

    // OPTIONAL FUNCTION
    void display() {
        if (!root) {
            return;
        }

        vector<string> representation;
        queue<AVLNode*> q;
        AVLNode* curr;

        q.push(root);
        representation.emplace_back(root->word);
        while (!q.empty()) {
            curr = q.front();
            q.pop();


            if (curr->left) {
                representation.emplace_back(curr->left->word);
                q.push(curr->left);
            } else {
                representation.emplace_back("NULL");
            }

            if (curr->right) {
                representation.emplace_back(curr->right->word);
                q.push(curr->right);
            } else {
                representation.emplace_back("NULL");
            }
        }

        for (const auto& elem : representation) {
            cout << elem << ", ";
        }
        cout << endl;
    }
};

int main() {
    AVLTree dict;

    dict.insert("yo", "greeting");
    dict.insert("gyatt", "boobs");
    dict.insert("rn", "right now");

    dict.display();

    return 0;
}
